<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Diana's Fashion Dash! ğŸ’…</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Nunito:wght@700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: linear-gradient(135deg, #ff9de2 0%, #ffc3f0 30%, #c4b5fd 60%, #93c5fd 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: 'Press Start 2P', monospace;
    overflow: hidden;
  }

  h1 {
    font-size: 22px;
    color: #fff;
    text-shadow: 3px 3px 0 #e879f9, 6px 6px 0 #a855f7;
    margin-bottom: 10px;
    letter-spacing: 2px;
  }

  #ui-bar {
    display: flex;
    gap: 30px;
    margin-bottom: 8px;
    font-size: 10px;
    color: #fff;
    text-shadow: 2px 2px 0 #a855f7;
  }

  #game-wrapper {
    position: relative;
    border: 4px solid #e879f9;
    border-radius: 12px;
    box-shadow: 0 0 0 4px #a855f7, 0 0 40px #e879f977, 0 0 80px #a855f744;
    overflow: hidden;
  }

  canvas {
    display: block;
    background: transparent;
  }

  #msg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(30,0,50,0.88);
    border: 3px solid #e879f9;
    border-radius: 10px;
    padding: 20px 30px;
    color: #fff;
    font-size: 11px;
    text-align: center;
    line-height: 2;
    pointer-events: none;
  }

  #msg .big { font-size: 16px; color: #f0abfc; display: block; margin-bottom: 10px; }
  #msg .sub { font-size: 8px; color: #c4b5fd; }

  #mute-btn {
    margin-top: 8px;
    background: rgba(255,255,255,0.2);
    border: 2px solid #e879f9;
    color: #fff;
    font-family: 'Press Start 2P', monospace;
    font-size: 8px;
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.2s;
  }
  #mute-btn:hover { background: rgba(232,121,249,0.4); }
</style>
</head>
<body>

<h1>âœ¨ DIANA'S FASHION DASH âœ¨</h1>
<div id="ui-bar">
  <span>SCORE: <span id="score-display">0</span></span>
  <span>HIGH: <span id="hi-display">0</span></span>
  <span>LIVES: <span id="lives-display">â¤ï¸â¤ï¸â¤ï¸</span></span>
</div>
<div id="game-wrapper">
  <canvas id="c" width="800" height="280"></canvas>
  <div id="msg">
    <span class="big">DIANA'S FASHION DASH!</span>
    Press <b>SPACE</b> or <b>TAP</b> to start<br>
    <span class="sub">Jump over rocks & gaps Â· Collect brand logos!</span>
  </div>
</div>
<button id="mute-btn">ğŸ”Š MUSIC ON</button>

<script>
// â”€â”€ Audio Engine (Web Audio API retro chiptune) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const AC = new (window.AudioContext || window.webkitAudioContext)();
let musicOn = true;
let musicNodes = [];

function note(freq, start, dur, vol=0.12, type='square') {
  const osc = AC.createOscillator();
  const gain = AC.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, AC.currentTime + start);
  gain.gain.setValueAtTime(0, AC.currentTime + start);
  gain.gain.linearRampToValueAtTime(vol, AC.currentTime + start + 0.01);
  gain.gain.linearRampToValueAtTime(0, AC.currentTime + start + dur - 0.01);
  osc.connect(gain); gain.connect(AC.destination);
  osc.start(AC.currentTime + start);
  osc.stop(AC.currentTime + start + dur);
  musicNodes.push(osc);
}

// Fun upbeat chiptune melody loop
function playMusic() {
  if (!musicOn) return;
  const bpm = 160;
  const b = 60 / bpm;
  // Melody (square) - cheerful 8-bar loop
  const mel = [
    392,392,523,392, 440,440,587,440,
    494,494,659,494, 523,523,698,523,
    587,587,784,587, 659,659,880,659,
    587,523,494,440, 392,330,294,262
  ];
  mel.forEach((f,i) => note(f, i*b*0.5, b*0.45, 0.10, 'square'));
  // Bass (triangle)
  const bass = [196,196,196,196, 220,220,220,220, 247,247,247,247, 262,262,262,262,
                 294,294,294,294, 330,330,330,330, 294,294,247,247, 196,196,196,196];
  bass.forEach((f,i) => note(f, i*b*0.5, b*0.48, 0.08, 'triangle'));
  // Schedule loop
  const loopDur = mel.length * b * 0.5;
  setTimeout(() => { if(musicOn) playMusic(); }, loopDur * 1000 - 100);
}

function stopMusic() {
  musicNodes.forEach(n => { try { n.stop(); } catch(e){} });
  musicNodes = [];
}

document.getElementById('mute-btn').addEventListener('click', () => {
  musicOn = !musicOn;
  document.getElementById('mute-btn').textContent = musicOn ? 'ğŸ”Š MUSIC ON' : 'ğŸ”‡ MUSIC OFF';
  if (!musicOn) stopMusic();
  else { AC.resume(); playMusic(); }
});

function sfxJump() {
  const o = AC.createOscillator(), g = AC.createGain();
  o.type = 'square';
  o.frequency.setValueAtTime(300, AC.currentTime);
  o.frequency.linearRampToValueAtTime(600, AC.currentTime + 0.1);
  g.gain.setValueAtTime(0.15, AC.currentTime);
  g.gain.linearRampToValueAtTime(0, AC.currentTime + 0.15);
  o.connect(g); g.connect(AC.destination);
  o.start(); o.stop(AC.currentTime + 0.15);
}

function sfxCoin() {
  [800, 1200].forEach((f, i) => {
    const o = AC.createOscillator(), g = AC.createGain();
    o.type = 'sine'; o.frequency.value = f;
    g.gain.setValueAtTime(0.2, AC.currentTime + i*0.07);
    g.gain.linearRampToValueAtTime(0, AC.currentTime + i*0.07 + 0.1);
    o.connect(g); g.connect(AC.destination);
    o.start(AC.currentTime + i*0.07); o.stop(AC.currentTime + i*0.07 + 0.1);
  });
}

function sfxHit() {
  const o = AC.createOscillator(), g = AC.createGain();
  o.type = 'sawtooth'; o.frequency.value = 80;
  g.gain.setValueAtTime(0.3, AC.currentTime);
  g.gain.linearRampToValueAtTime(0, AC.currentTime + 0.3);
  o.connect(g); g.connect(AC.destination);
  o.start(); o.stop(AC.currentTime + 0.3);
}

// â”€â”€ Canvas Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const GROUND = H - 50;

// â”€â”€ Pixel art drawing helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function px(x, y, s, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, s, s);
}

function drawGrid(data, x0, y0, size, palette) {
  data.forEach((row, ry) => {
    [...row].forEach((ch, rx) => {
      if (ch !== ' ' && palette[ch]) {
        px(x0 + rx*size, y0 + ry*size, size, palette[ch]);
      }
    });
  });
}

// â”€â”€ Character Pixel Art â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Girl: blonde hair, navy blazer, face staring forward, holding leash
const GIRL_SCALE = 3;
const GIRL_W = 18 * GIRL_SCALE;
const GIRL_H = 32 * GIRL_SCALE;

// Palette
const GP = {
  H: '#f5c842', // hair blonde
  h: '#e6b030', // hair dark blonde
  S: '#ffe0c0', // skin
  s: '#f0c090', // shadow skin
  B: '#1e3a5f', // blazer navy
  b: '#162d4a', // blazer dark
  T: '#111111', // top black
  E: '#3a2010', // eye brown
  L: '#e8789a', // lips
  N: '#c5a080', // neck
  R: '#e0e8ff', // white eye
  P: '#f0a0c0', // pink cheek
  G: '#888888', // leash grey
  D: '#f5e6c0', // dog cream/blonde
  d: '#e6d0a0', // dog shadow
  C: '#cc2222', // dog collar red
  c: '#222222', // dark outline
};

// 18-wide, 32-tall pixel grid (each char = 1 pixel)
const GIRL_PIXELS = [
//        0         1
//        0123456789012345678
/* 0 */  '   HHHHHHHHHH     ',
/* 1 */  '  HHHHhHHhHHHH    ',
/* 2 */  ' HHHHhHHHhHHHHH   ',
/* 3 */  ' HHSSSSSSSSShHH   ',
/* 4 */  ' HHSRERSERSE SHH  ',
/* 5 */  ' HHSsEsssEssSSH   ',
/* 6 */  ' HHSSNSSSSSSsHH   ',
/* 7 */  '  HHSSLLSSSNHH    ',
/* 8 */  '   HHSNNNNNHH     ',
/* 9 */  '  HHHHNNNNNHhH    ',
/* 10*/  '  HBBBBNBBBBHH    ',
/* 11*/  '  HBBbBBbBBBHH    ',
/* 12*/  '  BBBbTTTbBBB     ',
/* 13*/  '  BBbTTTTTbBB     ',
/* 14*/  '  BBBbTbTbBBB     ',
/* 15*/  '  BBBBbbbBBBB     ',
/* 16*/  '  BBBBbBbBBBB     ',
/* 17*/  '  BBBBbBbBBBB     ',
/* 18*/  '   BBBbBbBBB      ',
/* 19*/  '   BBbBBBbBB      ',
/* 20*/  '   BBbBBBbBB      ',
/* 21*/  '   BBbBBBbBB      ',
/* 22*/  '   BBbBBBbBB      ',
/* 23*/  '   BTbBBBbTB      ',
/* 24*/  '   BTBBBBBTBGGGGG ',
/* 25*/  '   BTBBBBBTb    G ',
/* 26*/  '   BbBBBBBbB    G ',
/* 27*/  '   BbBBBBBbB    G ',
/* 28*/  '   BbBBBBBbB  DDG ',
/* 29*/  '   bbBBBBBbb  DDG ',
/* 30*/  '   bbBBBBBbb  CCG ',
/* 31*/  '   cBBBBBBBc  DDG ',
];

// Dog pixel art (little maltipoo, 8x8 pixels)
const DOG_SCALE = 3;
const DOG = [
  '  DDD   ',
  ' DDdDD  ',
  ' DREDd  ',
  ' DDLDd  ',
  ' DDDDD  ',
  ' DCDDD  ',
  ' DDDDD  ',
  '  D D   ',
];

function drawGirl(x, y, frame) {
  const s = GIRL_SCALE;
  // Leg animation
  const legOff = Math.floor(frame / 5) % 2 === 0 ? 0 : 1;
  drawGrid(GIRL_PIXELS, x, y, s, GP);
  // Animate legs slightly
  if (legOff) {
    ctx.fillStyle = GP.B;
    ctx.fillRect(x + 3*s, y + 29*s, 3*s, 3*s);
    ctx.fillRect(x + 9*s, y + 29*s, 3*s, 2*s);
  }
}

function drawDog(x, y) {
  drawGrid(DOG, x, y, DOG_SCALE, GP);
}

// â”€â”€ Collectible Brand Logos â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BRANDS = [
  { name: 'ZARA', color: '#000', bg: '#fff', pts: 10 },
  { name: 'NOTINO', color: '#fff', bg: '#c0392b', pts: 15 },
  { name: 'H&M', color: '#e2001a', bg: '#fff', pts: 10 },
  { name: 'MANGO', color: '#fff', bg: '#8B4513', pts: 12 },
  { name: 'DIOR', color: '#c0a060', bg: '#000', pts: 25 },
  { name: 'CHANEL', color: '#fff', bg: '#111', pts: 30 },
  { name: 'ASOS', color: '#fff', bg: '#e800a0', pts: 10 },
  { name: 'SANDRO', color: '#fff', bg: '#000', pts: 20 },
];

// â”€â”€ Background clouds & decoration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const clouds = Array.from({length: 6}, (_, i) => ({
  x: i * 160 + Math.random()*60, y: 20 + Math.random()*50,
  w: 80 + Math.random()*60, speed: 0.4 + Math.random()*0.3
}));

const bgBuildings = Array.from({length: 10}, (_, i) => ({
  x: i * 120, y: H - 130 - Math.random()*80,
  w: 60 + Math.random()*50, h: 100 + Math.random()*80,
  color: `hsl(${270 + Math.random()*60},${30+Math.random()*30}%,${60+Math.random()*20}%)`
}));

// â”€â”€ Game State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let state = 'idle'; // idle, playing, dead, gameover
let score = 0, hiScore = 0, lives = 3, frame = 0, speed = 4;
let invincible = 0;
let scrollX = 0, bgScroll = 0;

// Ground tiles
const TILE = 40;
let groundTiles = [];

// Player
const player = { x: 100, y: GROUND - GIRL_H, vy: 0, onGround: true, jumping: false };

// Obstacles: { x, type:'rock'|'gap', w, h }
let obstacles = [];
// Coins: { x, y, brand, collected, bounce }
let coins = [];
// Particles
let particles = [];

// Timers
let obstacleTimer = 0, coinTimer = 0;
let OBSTACLE_INTERVAL = 90;

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function doJump() {
  if (state === 'idle' || state === 'gameover') {
    startGame(); return;
  }
  if (state === 'dead') return;
  if (player.onGround) {
    player.vy = -14;
    player.onGround = false;
    sfxJump();
    AC.resume();
  }
}

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); doJump(); }
});
canvas.addEventListener('click', doJump);
canvas.addEventListener('touchstart', e => { e.preventDefault(); doJump(); });

// â”€â”€ Game Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame() {
  score = 0; lives = 3; frame = 0; speed = 4;
  player.x = 100; player.y = GROUND - GIRL_H;
  player.vy = 0; player.onGround = true;
  obstacles = []; coins = []; particles = [];
  obstacleTimer = 60; coinTimer = 80;
  invincible = 0;
  state = 'playing';
  document.getElementById('msg').style.display = 'none';
  AC.resume();
  if (musicOn) { stopMusic(); playMusic(); }
  // Generate initial ground
  groundTiles = [];
  for (let tx = 0; tx < W + 200; tx += TILE) {
    groundTiles.push({ x: tx, solid: true });
  }
}

// â”€â”€ Spawn Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnObstacle() {
  const r = Math.random();
  if (r < 0.5) {
    // rock
    const sz = 20 + Math.random() * 20;
    obstacles.push({ x: W + 40, type: 'rock', w: sz, h: sz + 5 });
  } else {
    // gap
    obstacles.push({ x: W + 40, type: 'gap', w: 40 + Math.random()*20, h: 60 });
  }
}

function spawnCoin() {
  const brand = BRANDS[Math.floor(Math.random() * BRANDS.length)];
  const yOff = Math.random() < 0.4 ? -60 : 0;
  coins.push({ x: W + 40, y: GROUND - 45 + yOff, brand, collected: false, bounce: Math.random()*Math.PI*2 });
}

function addParticles(x, y, color, n=8) {
  for (let i = 0; i < n; i++) {
    const ang = (Math.PI * 2 * i / n) + Math.random()*0.5;
    particles.push({
      x, y, vx: Math.cos(ang)*3*(0.5+Math.random()),
      vy: Math.sin(ang)*3*(0.5+Math.random()) - 2,
      life: 40, color, size: 4+Math.random()*4
    });
  }
}

// â”€â”€ Main Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update() {
  if (state !== 'playing') return;
  frame++;
  if (invincible > 0) invincible--;

  // Speed up over time
  speed = 4 + score / 500;
  if (speed > 12) speed = 12;

  // BG scroll
  bgScroll = (bgScroll + speed * 0.3) % (W + 200);
  scrollX += speed;

  // Ground tiles
  groundTiles.forEach(t => t.x -= speed);
  if (groundTiles[0] && groundTiles[0].x < -TILE) groundTiles.shift();
  while (groundTiles[groundTiles.length-1].x < W + TILE) {
    groundTiles.push({ x: groundTiles[groundTiles.length-1].x + TILE, solid: true });
  }

  // Clouds
  clouds.forEach(c => {
    c.x -= c.speed;
    if (c.x < -200) c.x = W + 100;
  });

  // Buildings
  bgBuildings.forEach(b => {
    b.x -= speed * 0.15;
    if (b.x + b.w < 0) b.x = W + b.w;
  });

  // Player physics
  player.vy += 0.7; // gravity
  player.y += player.vy;

  // Ground collision
  if (player.y >= GROUND - GIRL_H) {
    player.y = GROUND - GIRL_H;
    player.vy = 0;
    player.onGround = true;
  } else {
    player.onGround = false;
  }

  // Spawn obstacles
  obstacleTimer--;
  if (obstacleTimer <= 0) {
    spawnObstacle();
    OBSTACLE_INTERVAL = Math.max(50, 90 - score/100);
    obstacleTimer = OBSTACLE_INTERVAL + Math.floor(Math.random()*30);
  }

  // Spawn coins
  coinTimer--;
  if (coinTimer <= 0) { spawnCoin(); coinTimer = 60 + Math.floor(Math.random()*40); }

  // Update obstacles
  obstacles.forEach(o => o.x -= speed);
  obstacles = obstacles.filter(o => o.x > -100);

  // Collision with obstacles
  if (invincible === 0) {
    for (const o of obstacles) {
      if (o.type === 'rock') {
        const px1 = player.x + 10, py1 = player.y + 10;
        const pw = GIRL_W - 20, ph = GIRL_H - 10;
        if (px1 < o.x + o.w && px1 + pw > o.x &&
            py1 + ph > GROUND - o.h && py1 < GROUND) {
          takeDamage();
        }
      } else if (o.type === 'gap') {
        // Player falls if center is over gap and on ground
        const pc = player.x + GIRL_W/2;
        if (pc > o.x && pc < o.x + o.w && player.onGround) {
          takeDamage();
          player.y = GROUND - GIRL_H; player.vy = 0;
        }
      }
    }
  }

  // Update coins
  coins.forEach(c => {
    c.x -= speed;
    c.bounce += 0.08;
  });

  // Coin collection
  coins.forEach(c => {
    if (c.collected) return;
    const cx = c.x + 20, cy = c.y + Math.sin(c.bounce)*5 + 10;
    const px2 = player.x + 8, py2 = player.y + 5;
    if (cx > px2 && cx < px2 + GIRL_W - 10 && cy > py2 && cy < py2 + GIRL_H - 10) {
      c.collected = true;
      score += c.brand.pts;
      sfxCoin();
      addParticles(c.x + 20, c.y, c.brand.bg || '#ffd700');
    }
  });
  coins = coins.filter(c => !c.collected && c.x > -60);

  // Particles
  particles.forEach(p => {
    p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life--;
    p.size *= 0.95;
  });
  particles = particles.filter(p => p.life > 0);

  // Score over time
  if (frame % 6 === 0) score++;

  // Update UI
  document.getElementById('score-display').textContent = score;
  document.getElementById('hi-display').textContent = hiScore;
  document.getElementById('lives-display').textContent = 'â¤ï¸'.repeat(lives);
}

function takeDamage() {
  if (invincible > 0) return;
  sfxHit();
  lives--;
  invincible = 90;
  addParticles(player.x + GIRL_W/2, player.y + GIRL_H/2, '#ff0000', 12);
  if (lives <= 0) {
    state = 'gameover';
    if (score > hiScore) hiScore = score;
    stopMusic();
    const m = document.getElementById('msg');
    m.innerHTML = `<span class="big">ğŸ’” GAME OVER</span>Score: ${score}<br>High Score: ${hiScore}<br><br><span class="sub">SPACE / TAP to retry!</span>`;
    m.style.display = 'block';
  }
}

// â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw() {
  // Sky gradient
  const sky = ctx.createLinearGradient(0, 0, 0, H);
  sky.addColorStop(0, '#fce7ff');
  sky.addColorStop(0.6, '#e0e7ff');
  sky.addColorStop(1, '#ffd6f5');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, H);

  // Sun
  ctx.beginPath();
  const sunX = (W * 0.75 - bgScroll*0.02 + W*2) % W;
  ctx.arc(sunX, 50, 35, 0, Math.PI*2);
  const sunG = ctx.createRadialGradient(sunX, 50, 5, sunX, 50, 35);
  sunG.addColorStop(0, '#fff9a0');
  sunG.addColorStop(1, '#ffda44');
  ctx.fillStyle = sunG;
  ctx.fill();

  // Background buildings
  bgBuildings.forEach(b => {
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, b.y, b.w, b.h);
    // windows
    ctx.fillStyle = 'rgba(255,255,200,0.5)';
    for (let wy = b.y+10; wy < GROUND - 20; wy += 18) {
      for (let wx = b.x+5; wx < b.x+b.w-8; wx += 14) {
        if (Math.random() > 0.3 || (frame % 120 < 60)) // flicker
          ctx.fillRect(wx, wy, 8, 10);
      }
    }
  });

  // Clouds
  clouds.forEach(c => {
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    const blobs = [{x:0,y:0,r:20},{x:25,y:-8,r:25},{x:50,y:0,r:20},{x:75,y:-5,r:22},{x:c.w-15,y:0,r:15}];
    blobs.forEach(b => {
      ctx.beginPath();
      ctx.arc(c.x + b.x, c.y + b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    });
  });

  // Ground
  // Pavement pattern
  for (let tx = -(scrollX % (TILE*2)); tx < W + TILE; tx += TILE) {
    // Check if this is a gap area
    let isGap = false;
    obstacles.forEach(o => {
      if (o.type === 'gap' && tx + TILE > o.x && tx < o.x + o.w) isGap = true;
    });
    if (!isGap) {
      // Main ground
      ctx.fillStyle = '#c4b5fd';
      ctx.fillRect(tx, GROUND, TILE, H - GROUND);
      // Tile border
      ctx.fillStyle = '#a78bfa';
      ctx.fillRect(tx, GROUND, TILE, 4);
      ctx.fillStyle = '#7c3aed44';
      ctx.fillRect(tx+1, GROUND+4, TILE-2, 4);
      // Sparkle dots
      if ((tx/TILE + Math.floor(scrollX/TILE)) % 3 === 0) {
        ctx.fillStyle = '#ffd6f5';
        ctx.fillRect(tx + 18, GROUND + 8, 4, 4);
      }
    }
  }

  // Draw gaps (dark pit)
  obstacles.forEach(o => {
    if (o.type === 'gap') {
      const grd = ctx.createLinearGradient(0, GROUND, 0, H);
      grd.addColorStop(0, '#2d1b69');
      grd.addColorStop(1, '#0f0a2e');
      ctx.fillStyle = grd;
      ctx.fillRect(o.x, GROUND, o.w, H - GROUND);
      // Danger stripes
      ctx.fillStyle = 'rgba(255,50,50,0.3)';
      for (let sx = o.x - 10; sx < o.x + o.w; sx += 16) {
        ctx.beginPath();
        ctx.moveTo(sx, GROUND);
        ctx.lineTo(sx+8, GROUND);
        ctx.lineTo(sx-8, H);
        ctx.lineTo(sx-16, H);
        ctx.fill();
      }
    }
  });

  // Rocks
  obstacles.forEach(o => {
    if (o.type === 'rock') {
      const ry = GROUND - o.h;
      // Rock shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.ellipse(o.x + o.w/2, GROUND + 3, o.w/2 + 5, 8, 0, 0, Math.PI*2);
      ctx.fill();
      // Rock body
      const rg = ctx.createRadialGradient(o.x+o.w*0.4, ry+o.h*0.4, 2, o.x+o.w/2, ry+o.h/2, o.w);
      rg.addColorStop(0, '#b0b0c8');
      rg.addColorStop(0.5, '#7080a0');
      rg.addColorStop(1, '#404060');
      ctx.fillStyle = rg;
      // Jagged rock shape
      ctx.beginPath();
      ctx.moveTo(o.x + o.w*0.1, GROUND);
      ctx.lineTo(o.x, ry + o.h*0.6);
      ctx.lineTo(o.x + o.w*0.2, ry + o.h*0.2);
      ctx.lineTo(o.x + o.w*0.4, ry);
      ctx.lineTo(o.x + o.w*0.6, ry + o.h*0.15);
      ctx.lineTo(o.x + o.w, ry + o.h*0.4);
      ctx.lineTo(o.x + o.w * 0.9, GROUND);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#333355';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });

  // Coins (brand logos)
  coins.forEach(c => {
    if (c.collected) return;
    const by = c.y + Math.sin(c.bounce) * 5;
    const br = c.brand;

    // Coin glow
    ctx.save();
    ctx.shadowColor = br.bg;
    ctx.shadowBlur = 12;

    // Coin body
    ctx.fillStyle = br.bg;
    ctx.beginPath();
    ctx.roundRect(c.x, by, 44, 22, 4);
    ctx.fill();
    ctx.restore();

    // Brand text
    ctx.fillStyle = br.color;
    ctx.font = 'bold 7px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(br.name, c.x + 22, by + 11);

    // Shine
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fillRect(c.x + 2, by + 2, 40, 6);
  });

  // Draw dog (slightly ahead of girl, or at leash end)
  const dogX = player.x + GIRL_W + 2;
  const dogY = GROUND - DOG_SCALE * 8;
  drawDog(dogX, dogY);

  // Draw girl (with invincibility flash)
  if (invincible === 0 || Math.floor(invincible / 5) % 2 === 0) {
    drawGirl(player.x, player.y, frame);
  }

  // Particles
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life / 40;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    ctx.restore();
  });

  // HUD score flash on collect
  // Speed indicator
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fillRect(0, 0, W * (speed - 4) / 8, 3);
  ctx.fillStyle = '#f0abfc';
  ctx.fillRect(0, 0, W * (speed - 4) / 8, 3);

  // Invincibility bar
  if (invincible > 0) {
    ctx.fillStyle = '#ff000033';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#ff6666';
    ctx.fillRect(10, H - 30, (invincible / 90) * (W - 20), 8);
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 2;
    ctx.strokeRect(10, H - 30, W - 20, 8);
  }
}

// â”€â”€ Game Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
